> 官方建议rocketMQ的消息，不要超过4M。超过4M会影响mq的执行效率。
> 所以如果消息大于4M的话，就将消息进行拆分发送，然后通过mq的消息监听，将数据重新组合。

#### 消息拆分工具类

>我们需要一个工具类来帮助拆分消息。比如，将消息体拆分为多个部分，每部分大小小于 4MB。

```java
import java.util.ArrayList;
import java.util.List;

public class MessageSplitter {

    // 最大消息大小 4MB
    private static final int MAX_MESSAGE_SIZE = 4 * 1024 * 1024;

    public static List<String> splitMessage(String message) {
        List<String> parts = new ArrayList<>();
        int messageLength = message.length();
        int startIndex = 0;

        while (startIndex < messageLength) {
            int endIndex = Math.min(startIndex + MAX_MESSAGE_SIZE, messageLength);
            parts.add(message.substring(startIndex, endIndex));
            startIndex = endIndex;
        }
        
        return parts;
    }
}

```

#### 发送拆分后的消息

>然后，在服务中使用 RocketMQ 发送拆分后的消息。我们需要通过消息 ID 和顺序标识来确保接收方可以正确组装这些消息。

```
import org.apache.rocketmq.spring.core.RocketMQTemplate;
import org.apache.rocketmq.spring.annotation.MessageMapping;
import org.apache.rocketmq.spring.annotation.RocketMQListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class MessageService {

    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    private static final String TOPIC = "test-topic";

    public void sendLargeMessage(String largeMessage) {
        List<String> messageParts = MessageSplitter.splitMessage(largeMessage);

        for (int i = 0; i < messageParts.size(); i++) {
            String messagePart = messageParts.get(i);
            String messageId = "message-part-" + i + "-" + messageParts.size(); // 标识消息顺序

            // 发送拆分后的消息，消息体带有拆分信息
            rocketMQTemplate.convertAndSend(TOPIC, new SplitMessage(messageId, messagePart));
        }
    }
}

```