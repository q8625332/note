> [!note] 最好不能采取写扩散的模式，因为用户消息量会比较大，采取写扩散模式的话，未签收表的数据量会比较庞大，容易造成数据查询慢的情况。
> 
> 如何设计呢？
> 
> 可以考虑使用：
> 
> 1. **最大签收id+连续id范围的模式**。
>    这种模式需要id是连续的，如何id不是连续的，可以定义消息的群消息排序值，用于替换id的连续id范围。
>    id的连续范围，是用来判断用户消息是否漏签和跳签的。
> 2. **时间窗口+签收id集合的形式**。
>    这个模式是一个比较通用的模式。可以不用考虑用户id是否是连续的。
> 


**最大签收id+连续id范围的模式**


```text
//流程
用户 -> 用户批量，签收消息id集合 -> 后端记录用户最大的签收id，并且记录并合并id的范围

合并id的范围：

签收的是1，2，3  就记录成 1-3。

如果消息是1-5，但是客户端签收的是3，4。

后端记录的是3-4，这就是发生了漏签和跳签。生成用户最大签收id的时候，就需要判断用户是否发生了漏签和跳签的事件，然后根据签收范围来决定是否更新用户最大的签收id。

比如：

消息是1-6，初始化时用户最大的签收id是0，用户签收了3，4。记录3-4，然后用户的id范围就生成了0，3-4。更新最大签收id时，就需要判断这种情况。如果是漏签和跳签的情况，就不更新用户的最大签收id。反之则更新用户最大id。

用户拉取未签收消息的时候，就根据大于用户最大的签收id的方式，获取未签收的消息，并且排除id范围的已签收范围的id。


```

**表：**

**用户表**（简易描述，不写全，可以根据业务而定）

| 名字          | 描述         |
| ----------- | ---------- |
| id          | id         |
| name        | 名字         |
| max_sign_id | 最大签收id     |
| sign_scope  | 签收范围：0，3-5 |

**消息表**

| 名字          | 描述    |
| ----------- | ----- |
| id          | id    |
| group_id    | 群id   |
| form_id     | 发送人id |
| content     | 内容    |
| ext         | 扩展数据  |
| create_time | 创建时间  |
| update_time | 更新时间  |
**签收表**

| 名字          | 描述    |
| ----------- | ----- |
| id          | id    |
| group_id    | 群id   |
| to_id       | 收取人id |
| msg_id      | 消息id  |
| create_time | 创建时间  |


**时间窗口+签收id集合的形式**


```text

```
