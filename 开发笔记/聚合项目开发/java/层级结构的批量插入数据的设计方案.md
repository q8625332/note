## 业务介绍

在我们的业务中，层级结构数据插入，需要第一层数据插入后，拿到第一层的id后，赋值到第二层，然后插入第二层数据，拿到第二层的id后，赋值到第三层。这时候后第三层数据才可以插入。

那我们为什么要这样繁琐的插入的。前提条件是我们数据的id不能提交生成的原因，如果使用的不是自增的id。如果使用的是uuid就不存在这个业务问题。

## 当我们存在这个问题如何解决呢？

方案如下：

> 数据如下结构如下:

```java
//分组
Map<String, List<ImportOutsourcingOutboundDTO>> dtoMap = dtoList.stream()  
        .collect(Collectors.groupingBy(ImportOutsourcingOutboundDTO::getReceiptNo,  
                LinkedHashMap::new, Collectors.toList()));
```

> 首先定义好收集数据储存对象：

```java
//第一层的数据
List<OutsourcingRefundOutbound> newOutsourcingRefundOutbound = CollUtil.newArrayList();
//第二层item的数据
Map<String, List<OutsourcingRefundOutboundItem>> newOutsourcingRefundOutboundItemMap = MapUtil.newHashMap();  
//第三层bolt的数据
Map<String, List<OutsourcingRefundOutboundItemBolt>> newOutsourcingRefundOutboundItemBoltMap = MapUtil.newHashMap();
```
> 实现收集数据:

```java
//循环
dtoMap.forEach((k, v) -> {  
    ImportOutsourcingOutboundDTO firstData = v.get(0);  
    OutsourcingRefundOutbound order = new OutsourcingRefundOutbound();  
    order.setTenantId(req.getTenantId());  
    order.setRefundNo(firstData.getReceiptNo());  
    //item分组  
    Map<String, List<ImportOutsourcingOutboundDTO>> itemMap = v.stream().collect(Collectors.groupingBy(o ->  
                    StrUtil.join("&", o.getProductName(), o.getProductColor(), o.getCylinderNo()),  
            LinkedHashMap::new, Collectors.toList()));
    //收集新的item数据  
    List<OutsourcingRefundOutboundItem> newOutsourcingOrderItemList = CollUtil.newArrayList();  
    itemMap.forEach((k2, v2) -> {  
        ImportOutsourcingOutboundDTO firstItemData = v.get(0);  
        OutsourcingRefundOutboundItem item = new OutsourcingRefundOutboundItem();
        Product product = productMap.get(firstItemData.getProductName());  
        item.setProductName(firstItemData.getProductName());  
        if (ObjUtil.isNull(product)) {  
            error.add(StrUtil.format("[委外退货单]物料不存在，物料名称为：{},单号为：{}", firstItemData.getProductName(), firstItemData.getReceiptNo()));  
            item.setProductId(0L);  
            item.setProductCode(null);  
        } else {  
            item.setProductId(product.getId());  
            item.setProductCode(product.getCode());  
        }  
        item.setColor(firstItemData.getProductColor());
        //收集b 
        List<OutsourcingRefundOutboundItemBolt> newOutsourcingRefundOutboundItemBoltList = CollUtil.newArrayList();  
        v.forEach(dtoBolt -> {  
            OutsourcingRefundOutboundItemBolt bolt = new OutsourcingRefundOutboundItemBolt();  
            bolt.setTenantId(req.getTenantId());  
            /*bolt.setWarehouseLocationId(warehouseResp.getWarehouseLocation().getId());  
            bolt.setWarehouseLocationName(warehouseResp.getWarehouseLocation().getName());*/            //仓库模式            bolt.setWarehouseLocationId(-1L);  
            bolt.setWarehouseLocationName("");  
            bolt.setYardQuantity(Optional.ofNullable(dtoBolt.getQuantity()).orElse(BigDecimal.ZERO));  
            newOutsourcingRefundOutboundItemBoltList.add(bolt);  
        });  
        item.setCreatedTime(order.getCreatedTime());  
        item.setCreatedBy(0L);  
        item.setCreatedName(order.getCreatedName());  
        item.setLastModifiedTime(order.getCreatedTime());  
        item.setLastModifiedBy(0L);  
        item.setLastModifiedName(order.getCreatedName());  
        item.setLineRemark(firstItemData.getDetailsRemark());  
        //统计数据  
        if (item.getRefundQuantity() != null)  
            order.setRefundQuantity(order.getRefundQuantity() + item.getRefundQuantity());  
        if (item.getRefundQuantityOfYard() != null)  
            order.setRefundQuantityOfYard(order.getRefundQuantityOfYard().add(item.getRefundQuantityOfYard()));  
        if (item.getRefundQuantityOfMeter() != null)  
            order.setRefundQuantityOfMeter(order.getRefundQuantityOfMeter().add(item.getRefundQuantityOfMeter()));  
        newOutsourcingOrderItemList.add(item);  
        //赋值新增的bolt  
        if (CollUtil.isNotEmpty(newOutsourcingRefundOutboundItemBoltList)) {  
            newOutsourcingRefundOutboundItemBoltMap.put(firstData.getReceiptNo()  
                    .concat("&")  
                    .concat(k2), newOutsourcingRefundOutboundItemBoltList);  
        }  
    });  
    newOutsourcingRefundOutbound.add(order);  
    //赋值新增item  
    if (CollUtil.isNotEmpty(newOutsourcingOrderItemList)) {  
        newOutsourcingRefundOutboundItemMap.put(firstData.getReceiptNo(), newOutsourcingOrderItemList);  
    }  
});
```