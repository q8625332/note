# BatchProcessUtil 使用示例  
  
## 概述  
  
`BatchProcessUtil` 是一个通用的批处理工具类，用于处理需要分批执行的数据库操作，避免一次性处理大量数据造成的性能问题。  
  
## 主要特性  
  
- ✅ **分批处理**: 避免一次性处理大量数据  
- ✅ **自动重试**: 支持失败重试机制  
- ✅ **性能控制**: 可配置休眠时间，避免对数据库造成压力  
- ✅ **详细日志**: 完整的处理过程日志记录  
- ✅ **异常处理**: 优雅的异常处理和线程中断处理  
- ✅ **灵活配置**: 支持多种配置选项  
  
## 基本用法  
  
### 1. 最简单的用法（使用默认配置）~~~~  
  
```java  
// 默认批次大小500，休眠50ms  
BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(() -> {  
    return dao.updateSomething(); // 返回本次处理的数量  
});  
  
boolean success = result.isSuccess();  
int totalProcessed = result.getTotalProcessed();  
```  
  
### 2. 指定批次大小  
  
```java  
BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(  
    () -> dao.deleteSomething(1000), // 每次删除1000条  
    1000 // 批次大小  
);  
```  
  
### 3. 指定批次大小和操作名称  
  
```java  
BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(  
    () -> dao.updateUserStatus(userId, status),    500,    "更新用户状态"  
);  
```  
  
### 4. 完整配置  
  
```java  
BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(  
    () -> dao.processData(params),    new BatchProcessUtil.BatchConfig()        .batchSize(300)                    // 每批处理300条  
        .sleepMillis(100)                  // 每批后休眠100ms  
        .operationName("处理用户数据")       // 操作名称（用于日志）  
        .enableLog(true)                   // 启用日志（默认true）  
        .maxRetries(3)                     // 最大重试3次  
);  
```  
  
## 实际应用示例  
  
### 示例1: 批量更新用户通知状态  
  
```java  
@Override  
public boolean updateUserRead(String userId, long now) {  
    if (StringUtils.isBlank(userId)) {  
        log.warn("updateUserRead: userId为空");  
        return false;    }  
  
    // 使用批处理工具类  
    BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(  
        () -> noticeDao.updateUserReadBatch(userId, now, 500),  
        new BatchProcessUtil.BatchConfig()  
            .batchSize(500)  
            .sleepMillis(50)  
            .operationName("更新用户通知已读状态[userId=" + userId + "]")  
    );  
  
    if (!result.isSuccess()) {  
        log.error("updateUserRead: 批处理执行失败, userId={}, error={}",   
userId, result.getErrorMessage());  
    }  
  
    return result.getTotalProcessed() > 0;
}  
```  
  
### 示例2: 批量清理过期数据  
  
```java  
@Override  
public void cleanExpiredData(long expireTime) {  
    BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(  
        () -> dataDao.deleteExpiredData(expireTime, 1000),  
        new BatchProcessUtil.BatchConfig()  
            .batchSize(1000)  
            .sleepMillis(200)  
            .operationName("清理过期数据[expireTime=" + expireTime + "]")  
            .maxRetries(2)  
    );  
        log.info("清理过期数据完成: 总共清理{}条, 执行{}批次",   
result.getTotalProcessed(), result.getBatchCount());  
}  
```  
  
### 示例3: 批量同步数据  
  
```java  
@Override  
public void syncUserData(List<String> userIds) {  
    AtomicInteger processedCount = new AtomicInteger(0);  
    BatchProcessUtil.BatchResult result = BatchProcessUtil.executeBatch(  
        () -> {  
            // 每次处理100个用户  
            int startIndex = processedCount.get();  
            int endIndex = Math.min(startIndex + 100, userIds.size());  
            if (startIndex >= userIds.size()) {  
                return 0; // 没有更多数据需要处理  
            }  
                        List<String> batchUserIds = userIds.subList(startIndex, endIndex);  
            int processed = syncService.syncUsers(batchUserIds);  
            processedCount.addAndGet(processed);  
            return processed;  
        },  
        new BatchProcessUtil.BatchConfig()  
            .batchSize(100)  
            .sleepMillis(100)  
            .operationName("同步用户数据")  
    );  
}  
```  
  
## 配置说明  
  
### BatchConfig 配置项  
  
| 配置项 | 默认值 | 说明 |  
|--------|--------|------|  
| batchSize | 500 | 每批处理的数量，当返回值 >= batchSize 时继续下一批 |  
| sleepMillis | 50 | 每批处理后的休眠时间（毫秒） |  
| operationName | "批处理操作" | 操作名称，用于日志输出 |  
| enableLog | true | 是否启用详细日志 |  
| maxRetries | 0 | 最大重试次数，0表示不重试 |  
  
### BatchResult 结果  
  
| 字段 | 说明 |  
|------|------|  
| totalProcessed | 总共处理的数量 |  
| batchCount | 执行的批次数量 |  
| success | 是否成功完成 |  
| errorMessage | 错误信息（如果失败） |  
  
## 注意事项  
  
1. **返回值含义**: Lambda表达式必须返回本次实际处理的数量  
2. **终止条件**: 当返回值 < batchSize 时，批处理会自动终止  
3. **异常处理**: 工具类会自动处理异常和线程中断  
4. **性能考虑**: 合理设置batchSize和sleepMillis，避免对数据库造成过大压力  
5. **重试机制**: 启用重试时，每次重试前会有递增的等待时间  
  
## 最佳实践  
  
1. **根据数据量调整批次大小**: 数据量大时使用较大的批次，数据量小时使用较小的批次  
2. **设置合适的休眠时间**: 高频操作设置较长休眠时间，低频操作可以设置较短休眠时间  
3. **使用有意义的操作名称**: 便于日志分析和问题排查  
4. **检查处理结果**: 始终检查BatchResult的success状态  
5. **合理使用重试**: 只对可能因网络抖动等临时问题失败的操作启用重试


## 代码


```java
package com.ljq.util;  
  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
  
/**  
 * 批处理工具类  
 * 用于处理需要分批执行的数据库操作，避免一次性处理大量数据造成的性能问题  
 *   
* @author ljq  
 */public class BatchProcessUtil {  
    private static final Logger log = LoggerFactory.getLogger(BatchProcessUtil.class);  
    /**  
     * 默认批处理大小  
     */  
    public static final int DEFAULT_BATCH_SIZE = 500;  
    /**  
     * 默认休眠时间（毫秒）  
     */  
    public static final long DEFAULT_SLEEP_MILLIS = 50;  
    /**  
     * 批处理配置  
     */  
    public static class BatchConfig {  
        private int batchSize = DEFAULT_BATCH_SIZE;  
        private long sleepMillis = DEFAULT_SLEEP_MILLIS;  
        private String operationName = "批处理操作";  
        private boolean enableLog = true;  
        private int maxRetries = 0; // 最大重试次数  
        public BatchConfig batchSize(int batchSize) {  
            this.batchSize = batchSize;  
            return this;  
        }  
        public BatchConfig sleepMillis(long sleepMillis) {  
            this.sleepMillis = sleepMillis;  
            return this;  
        }  
        public BatchConfig operationName(String operationName) {  
            this.operationName = operationName;  
            return this;  
        }  
        public BatchConfig enableLog(boolean enableLog) {  
            this.enableLog = enableLog;  
            return this;  
        }  
        public BatchConfig maxRetries(int maxRetries) {  
            this.maxRetries = maxRetries;  
            return this;  
        }  
        // Getters  
        public int getBatchSize() { return batchSize; }  
        public long getSleepMillis() { return sleepMillis; }  
        public String getOperationName() { return operationName; }  
        public boolean isEnableLog() { return enableLog; }  
        public int getMaxRetries() { return maxRetries; }  
    }  
    /**  
     * 批处理结果  
     */  
    public static class BatchResult {  
        private final int totalProcessed;  
        private final int batchCount;  
        private final boolean success;  
        private final String errorMessage;  
        public BatchResult(int totalProcessed, int batchCount, boolean success, String errorMessage) {  
            this.totalProcessed = totalProcessed;  
            this.batchCount = batchCount;  
            this.success = success;  
            this.errorMessage = errorMessage;  
        }  
        public int getTotalProcessed() { return totalProcessed; }  
        public int getBatchCount() { return batchCount; }  
        public boolean isSuccess() { return success; }  
        public String getErrorMessage() { return errorMessage; }  
    }  
  
    /**  
     * 批处理操作，带配置参数  
     */  
    @FunctionalInterface  
    public interface BatchConfigAwareOperation {  
        int operate(BatchConfig config);  
    }  
    /**  
     * 执行批处理操作  
     *   
* @param batchOperation 批处理操作，返回本次处理的数量  
     * @param config 批处理配置  
     * @return 批处理结果  
     */  
    public static BatchResult executeBatch(BatchConfigAwareOperation batchOperation, BatchConfig config) {  
        int totalProcessed = 0;  
        int currentBatchProcessed;  
        int executeCount = 1;  
        String errorMessage = null;  
        if (config.isEnableLog()) {  
            log.info("[{}] 开始分批处理，batchSize={}, sleepMillis={}ms",   
config.getOperationName(), config.getBatchSize(), config.getSleepMillis());  
        }  
        try {  
            do {  
                int retryCount = 0;  
                currentBatchProcessed = 0;  
                // 重试机制  
                while (retryCount <= config.getMaxRetries()) {  
                    try {  
                        currentBatchProcessed = batchOperation.operate(config);  
                        break; // 成功执行，跳出重试循环  
                    } catch (Exception e) {  
                        retryCount++;  
                        if (retryCount > config.getMaxRetries()) {  
                            throw e; // 超过最大重试次数，抛出异常  
                        }  
                        if (config.isEnableLog()) {  
                            log.warn("[{}] 第{}次执行失败，进行第{}次重试: {}",   
config.getOperationName(), executeCount, retryCount, e.getMessage());  
                        }  
                        // 重试前稍微等待  
                        Thread.sleep(config.getSleepMillis() * retryCount);  
                    }  
                }  
                totalProcessed += currentBatchProcessed;  
                if (config.isEnableLog()) {  
                    log.info("[{}] 第{}次处理，本次处理={}条，累计处理={}条",   
config.getOperationName(), executeCount++, currentBatchProcessed, totalProcessed);  
                }  
                // 如果本次处理了数据，休息一下避免对数据库造成过大压力  
                if (currentBatchProcessed > 0 && config.getSleepMillis() > 0) {  
                    Thread.sleep(config.getSleepMillis());  
                }  
                } while (currentBatchProcessed >= config.getBatchSize());  
            if (config.isEnableLog()) {  
                log.info("[{}] 分批处理完成，总共处理={}条数据，执行批次={}次",   
config.getOperationName(), totalProcessed, executeCount - 1);  
            }  
            return new BatchResult(totalProcessed, executeCount - 1, true, null);  
            } catch (InterruptedException e) {  
            errorMessage = "线程被中断: " + e.getMessage();  
            log.error("[{}] 线程被中断，停止处理: {}", config.getOperationName(), e.getMessage(), e);  
            Thread.currentThread().interrupt();  
            return new BatchResult(totalProcessed, executeCount - 1, false, errorMessage);  
            } catch (Exception e) {  
            errorMessage = "处理异常: " + e.getMessage();  
            log.error("[{}] 处理异常，停止处理: {}", config.getOperationName(), e.getMessage(), e);  
            return new BatchResult(totalProcessed, executeCount - 1, false, errorMessage);  
        }  
    }  
    /**  
     * 使用默认配置执行批处理  
     */  
    public static BatchResult executeBatch(BatchConfigAwareOperation batchOperation) {  
        return executeBatch(batchOperation, new BatchConfig());  
    }  
    /**  
     * 使用指定批次大小执行批处理  
     */  
    public static BatchResult executeBatch(BatchConfigAwareOperation batchOperation, int batchSize) {  
        return executeBatch(batchOperation, new BatchConfig().batchSize(batchSize));  
    }  
    /**  
     * 使用指定批次大小和操作名称执行批处理  
     */  
    public static BatchResult executeBatch(BatchConfigAwareOperation batchOperation, int batchSize, String operationName) {  
        return executeBatch(batchOperation, new BatchConfig().batchSize(batchSize).operationName(operationName));  
    }  
}
```
